---
title: SplashKit Online C# Support Research
description:
  A report outlining foundation research into how C# could be supported in SplashKit Online.
---

# SplashKit Online C# Support Research
Finalised 09/10/2024, by Jessica Balsillie

<sup><sub>_Transcribed from PDF to markdown by Sean Boettger - any mistakes in formatting are my fault!_</sup></sub>

## Background: C# on the desktop

There are two kinds of C# desktop applications: bytecode executables and native executables.

A bytecode C# executable is a list of instructions for the C# virtual machine, which can either be interpreted by a VM application or JIT-compiled into native machine code. As such, to run a bytecode C# executable, a separate runtime application, the CLR (common language runtime) must be present on the system to do this processing. This runtime also manages additional things such as garbage collection.

A native C# executable is a normal executable which the processor can run directly, like those of a language like C. The bytecode generated by the C# compiler is further compiled into machine code, and responsibilities that would usually fall to the CLR must be handled by code in the executable itself.

# C# on the web

To use C# on the web, our machine code becomes WASM, and we thus have several options:

1. An interpreter.
2. A compiler producing WASM binaries with a runtime dependency.
3. A compiler producing WASM binaries with an embedded runtime.
4. A C#-to-[language]-to-WASM compiler.

For (1) and (2), the runtime component must run in the browser; i.e. it must be written in JavaScript, have a WASM binary, or be compilable to a WASM binary somehow (which additionally requires that we can license the source code properly.)

For (3) and (4), the solution can either run in the browser, or on a server, with the client receiving a WASM binary. In terms only of this problem, the latter is vastly simpler, as it allows us to run the solution in a normal environment. However, in terms of the problem of SKO broadly, it makes the website substantially more complex and expensive to run, as the site could no longer be statically served.

(Another solution is to forego WASM and use a C#-to-JavaScript transpiler. This would of course be slower, but it may not be so slow as to seriously affect the performance of the site. However, transpilation is complicated by the many differences between the languages, and already existing solutions are slim. Furthermore, if a serverless approach is desired, such a transpiler would also itself need to be made to run in the browser. Ultimately, we likely must compile C# to WASM regardless, and so this is the solution to pursue.)

### wasm-tools

The solution most supported by Microsoft would be to use the dotnet SDK and the wasm-tools workload, which relies ultimately on Emscripten. This will produce a bundle consisting of a WASM application binary (CLR included) and a JavaScript runtime for handling I/O and so on. The SDK would either need be run on a server or be made to run in the browser.

To reproduce a basic C# WASM project requires the following:
1. Install the .NET CLI
2. Run `dotnet workload install wasm-tools`
3. Run `dotnet workload install wasm-experimental`
4. Create the C# project with `dotnet new wasmbrowser`
5. Build the project with `dotnet build`

The directory `./wwwroot` will contain a dummy HTML file and a JavaScript file with basic usage of the .NET JS library, which handles interfacing with the WASM executable. The library itself and all generated files will be located in `./bin/[build type]/[version]/wwwroot`.

### A web compiler

We must not only run C# on the web, but compile C# on the web. Compiling the SDK itself to WASM would be a significant undertaking, and so alternative uses of it are more preferable. We can instead use the SDK to compile a C#-to-bytecode compiler. The C# Roslyn compiler is well-supported as a library ( `Microsoft.CodeAnalysis.CSharp` ), and as binaries generated by the SDK contain a CLR, they can execute arbitrary C# bytecode assemblies.

Usage of the Roslyn compiler library is essentially as follows:
1. Parse source code into an AST with `CSharpSyntaxTree.ParseText`
2. Load relevant assemblies as `MetadataReference` objects.
3. Create a compilation object with `CSharpCompilation`.Create from the AST and metadata references.
4. Emit bytecode with `CSharpCompilation.Emit`
5. Load the bytecode as an assembly with `AppDomain.CurrentDomain.Load`

To load the other assemblies that the user's assembly will depend on, it is necessary to fetch them from the server. Fortunately, the HttpClient class is already implemented by the WASM runtime and makes use of the browser's native facilities for this. For basic functionality, the following assemblies are adequate:

1. `mscorlib.dll`
2. `netstandard.dll`
3. `System.dll`
4. `System.Runtime.dll`

These pre-built .NET assemblies are not necessarily cross-platform, and should be sourced from the C# WASM SDK itself. (I simply copied them from the `./bin` folder of the project and placed them at the root of the server.)

## SplashKit in web C#

Merely being able to compile and run C# code in the browser is not enough for SKO to support C#. We also need for the user's C# assembly to make use of the SplashKit runtime and call SplashKit functions somehow.

### Native dependencies

The C# WASM toolkit provides support for native dependencies; that is, for accessing functions and types in unmanaged, non-C# binaries.

`.csproj`
```C#
<ItemGroup>
    <NativeFileReference Include="SplashKitBackendWASM.o" />
</ItemGroup>
```

`SplashKit.cs (generated by the translator)`
```C#
//          v modified to ref our library
[DllImport("SplashKitBackendWASM", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_circle__color__double__double__double private static extern void __sklib__draw_circle__color__double__double__double(__sklib_color clr, double x, double y, double radius);

// ...

public static void DrawCircle(Color clr, double x, double y, double radius)
{
    // ...
    __sklib__draw_circle__color__double__double__double(__skparam__clr, __skparam__x, __skparam__y, __skparam__radius);
}
```
As the SplashKit Online project has already generated a WASM library version of SplashKit, we can use this C# functionality to call SplashKit functions directly from the library. A set of bindings would be needed, as unmanaged code does not expose what functions it contains, but this is already generated by the SplashKit translator project, and so little additional work is necessary.

To use the C# SplashKit bindings, which can be found in `SplashKit.cs` under `generated/csharp` in the `splashkit-core` project, the library must be compiled with the C bindings which can themselves be found under `generated/clib`.

- `lib_type_mapper.cpp`
- `lib_type_mapper.h`
- `sk_clib.cpp`
- `sk_clib.h`

The `SplashKitBackendWASM` file referenced above must be an object file (`.o`) emitted by the Emscripten compiler. It should be compiled with the flag `-fPIC` (Position Independent Code), and linked with the flags `-shared -s RELOCATABLE=1`, in order to create a relocatable library that can be linked against by the C# WASM SDK.

```makefile
emcc $(SRC_FILE) -fPIC -o $(OBJ_FILE)
# ...
emcc $(OBJ_FILES) -shared -s RELOCATABLE=1 -o SplashKitBackendWASM.o
```

(I faced issues with undefined SDL symbols while building, but was unable to determine their cause. When compiling `SplashKitBackendWASM.o`, in which these symbols are referenced, the Emscripten compiler did not complain about them; only the C# SDK identified them. For the sake of prototyping, I used the MSBuild property `<WasmAllowUndefinedSymbols>True</WasmAllowUndefinedSymbols>` to ignore these errors.)

This allowed me to successfully use functions like `WriteLine` from the project's code in the browser.

As the WASM SDK uses Emscripten in order to link this object file, it may be that the Roslyn compiler library simply does not support this native dependencies feature, and so there is no natural way in which to link the SplashKit library to the user's own code. Due to a lack of substantial documentation, I was unable to confirm this.

Regardless, linking the project's own assembly to the user's assembly sufficed for a prototype, and I was able to call SplashKit functions from the user's code. In
future, a dummy assembly that does nothing but link to the SplashKit object file could be generated instead, to avoid bloat and namespace pollution, but that was
unnecessary for this prototype.

(User code)
```C#
using System;
using System.Threading.Tasks;
using SplashKitSDK;

public class Program {
    public static async Task<string> Run(){
        SplashKitSDK.SplashKit.WriteLine("Hello from SplashKit.");
        return "Hello from the user code.";
    }
}
```

(Project code)
```C#
var assembly = /* compiled assembly */;
var types = assembly.GetExportedTypes();
var type = types.FirstOrDefault();
var methodInfo = type.GetMethod("Run");
var instance = Activator.CreateInstance(type);
var result = await (Task<string>)methodInfo.Invoke(instance, null);
```

As I was unable to resolve the SDL symbol issues, I was unable to prototype the graphics and audio subsystems of SplashKit. Attempting to use functions like `OpenWindow` would naturally yield runtime errors. It is unclear why these symbols are undefined, as they are usually exported properly when building the SplashKit Online JavaScript runtime. There may be issues in my own development environment.

### Alternative: JavaScript bindings

Rather than interfacing with a library, the JavaScript interop functionality in the C# WASM toolkit could instead be used to call SplashKit functions using the existing JavaScript binding. This interop facility is provided in the namespace `System.Runtime.InteropServices.JavaScript`.
```C#
//         function      module
[JSImport("write_line", "SplashKitBackendWASM")]
static partial string WriteLine(string data);
```

For simple functions, it is trivial to generate bindings like this, as primitives are automatically marshalled. However, marshalling becomes a problem when more complex types are involved, as JavaScript is of course dynamically-typed.

Marshalling can be specified with attributes.
```C#
[JSImport("getDay", "MyDate")]
public static partial int GetDay([JSMarshalAs<JSType.Date>] DateTime date);
```

```C#
[JSImport("getToday", "MyDate")]
[return: JSMarshalAs<JSType.Date>]
public static partial DateTime GetToday();
```

References to JavaScript objects can be manipulated with the `JSObject` type, however function fields in objects cannot be accessed, and so additional glue code would need be written in JavaScript to facilitate their use.

```JavaScript
// non-glue
class MyClass {
    function MyFunction(args...){
        // ...
    }
}

// glue
function _MyClass_MyFunction(instance, args...){
    return instance.MyFunction(args...);
}
```
``` C#
[JSImport("_MyClass_MyFunction")]
public static partial ... MyFunction(JSObject instance, args...);
```

In future, there may be support for serialising and deserialising of objects via JSON, but this is currently not supported. ([This is the relevant GitHub issue.](https://Sorry-the-pdf-I-transcribed-this-from-had-links-removed.../)) As such, glue code is necessary to perform this marshalling explicitly. Furthermore, marshalling through JSON will naturally have an adverse impact on performance.
``` JavaScript
class MyStruct {
    constructor(x) {
        this.x = x;
    }
}

function createStruct(){
    return new MyStruct(123);
}

function __createStruct(){
    return MyToJsonFunction(createStruct());
}
```
``` C#
public static MyStruct {
    public int x;
}

[JSImport("__createStruct")]
public static partial string __CreateStruct();

public static MyStruct CreateStruct(){
    return MyFromJsonFunction(__CreateStruct());
}
```

Given these marshalling issues: even with the SplashKit JavaScript binding already existing, accessing it from C# would require writing yet more bindings for the entirety of SplashKit, which was not within the scope of this research.

## Conclusion

Not only is it possible to compile C# as a WASM executable, it is possible to embed a C# compiler in the browser. Linking the SplashKit library to this executable, and to assemblies generated by the in-browser compiler proved possible, but faced several major issues. SDL libraries were unable to be linked properly for unknown reasons, and so the majority of user-facing functionality remains unimplemented. Further research is required in order to support C# in SplashKit Online, for which this work provides a foundation.

## References

1. [C# WASM example project guide](https://Sorry-the-pdf-I-transcribed-this-from-had-links-removed.../)
2. [C# WASM example project](https://Sorry-the-pdf-I-transcribed-this-from-had-links-removed.../)
3. [Documentation for Microsoft.CodeAnalysis.CSharp](https://Sorry-the-pdf-I-transcribed-this-from-had-links-removed.../)
4. [Another web-based C# compiler project](https://Sorry-the-pdf-I-transcribed-this-from-had-links-removed.../)
5. [C# WASM native dependencies](https://Sorry-the-pdf-I-transcribed-this-from-had-links-removed.../)
6. [.NET WASM Javascript interop guide](https://Sorry-the-pdf-I-transcribed-this-from-had-links-removed.../)
